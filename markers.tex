\section{Functional Name Component: Special Markers}

In a variety of situations, name components need to represent commands or annotations that can appear at arbitrary levels in the name hierarchy, intermixed with the human readable components that are analogous to pieces of file names.
In these cases, the position in the name is not able to distinguish the componentâ€™s role and hence one must rely on coding conventions in the component itself.
Wherever possible, however, the function or meaning of a name component should be determined by its context within the overall name and under the specific application semantics, and human readable components should be used where they will not be mistaken for functional name components.

The specification of UTF-8 prohibits certain octet values from occurring anywhere in a UTF-8 encoded string.
These are the (hex) octet values \verb|0xC0|, \verb|0xC1|, and \verb|0xF5| to \verb|0xFF|.
In addition, the null octet \verb|00| is used for string termination and so does not encode a usable character.
Thus, these make good \emph{markers} to identify components of a NDN name that play special functional roles such as for versioning and segment numbering.

The following sections introduce some naming conventions that assign the prohibited octet values to the specific functions: segmenting, versioning, and sequencing.
Note that the meaning of the special markers are application-layer information.
From the router's perspective these functional components are no different from other name components.
Although, the specific semantics of the special markers is ultimately defined by the application, the consistent use the naming convention helps applications to get the most advantage of the NDN architecture.
For example, when the segmenting convention is properly used by the application, this application can get additional benefits from NDN routers, if a caching policy that prioritizes caching of the whole Data is in place.
Further discussion about the specific properties and advantages that naming conventions, defining semantics of the name component(s), bring to the applications is outside the scope of this document.
However, it is an active discussion within NDN project team and beyond.

\subsubsection{Marker and Value Encoding}
\label{sec:marker-encoding}

In the current convention, a functional name component is constructed using a \emph{marker octet} from the UTF-8 prohibited set as the first octet, followed by the value in the following format based on non-negative integer encoding of NDN-TLV~\cite{ndn-tlv}:

\vspace{0.2cm}

\begin{minipage}[c]{0.5\textwidth}
\begin{verbatim}

    NameComponentWithMarker ::= NAME-COMPONENT-TYPE TLV-LEGTH
                                  Marker
                                  includedNonNegativeInteger

    Marker ::= BYTE

    includedNonNegativeInteger ::= BYTE+

    NDN-TLV := TLV-TYPE TLV-LENGTH TLV-VALUE?
    TLV-TYPE := VAR-NUMBER
    TLV-LENGTH := VAR-NUMBER
    TLV-VALUE := BYTE+

\end{verbatim}
\end{minipage}

The only difference between \texttt{includedNonNegativeInteger} and \texttt{nonNegativeInteger} defined in NDN-TLV spec~\cite{ndn-tlv} is the way the size of the stored non-negative integer is calculated.
More specifically, length value of the TLV element containing \texttt{includedNonNegativeInteger} MUST be either 1, 2, 4, or 8 PLUS size of the prefixed elements.
For \texttt{NameComponentWithMarker}, given that prefix is always a marker with size 1, the only values allowed values fro TLV-LENGTH are: 2, 3, 5, and 9.

Depending on the length MINUS size of the prefixed elements, a \texttt{includedNonNegativeInteger} is encoded as follows:
\begin{itemize}
\item if the length MINUS size of the prefixed elements is 1 (i.e., the value length is 1 octet), the \texttt{inclu\-dedNonNe\-ga\-ti\-veInteger} is encoded in one octet;
\item if the length MINUS size of the prefixed elements is 2 (= value length is 2 octets), the \texttt{inclu\-dedNonNe\-ga\-ti\-veInteger} is encoded in 2 octets, in net byte-order;
\item if the length MINUS size of the prefixed elements is 4 (= value length is 4 octets), the \texttt{includedNonNe\-ga\-ti\-veInteger} is encoded in 4 octets, in net byte-order;
\item if the length MINUS size of the prefixed elements is 8 (= value length is 8 octets), the \texttt{includedNonNe\-ga\-ti\-veInteger} is encoded in 8 octets, in net byte-order.
\end{itemize}

In the future, we plan to extend the naming conventions and encoding methods to include different types of markers that could extend beyond a single naming component.

\subsection{Segmenting}
\label{sec:segmenting}

Segmenting is used when the application wants to cut a large data into small pieces.
For segmenting purposes, we define two special markers (see Table~\ref{tab:segmenting}): \verb|0x00| for sequence-based segmentation and \verb|0xFB| for byte offset segmentation.
When sequence-based segmentation is used, each segmented Data packet should be assigned a sequential segment number, starting from 0: 0, 1, 2, ...
When byte-offset segmentation is used, each segmented Data packet should be assigned a byte offset of the segmented content: 0, (content size in first Data packet), (sum of content sizes in first two Data packets), ...

The segment number is recommended to be put as the last name component, not including the implicit digest.

\begin{table}[h!]
  \centering
  \caption{Segmenting markers}
  \label{tab:segmenting}
  \begin{tabular}{|l|l|l|}
    \hline
    Marker & Value meaning \\
    \hline \hline
    \verb|0x00| & Segment-number \\
    \verb|0xFB| & Byte offset \\
    \hline
  \end{tabular}
\end{table}

\subsection{Versioning}
\label{sec:version}

Versioning is necessary if the application wants to update previously published data and publish again under the same name.
Since NDN mandates every data packet to have a unique name, a version component must be added to allow unambiguous naming for different versions of the data.

The current convention define use of \verb|0xFD| marker for versioning (Table~\ref{tab:versioning}).
The following value should represent number of milliseconds since UNIX epoch (Thursday, 1 January 1970) not counting leap seconds, generated from the system clock to indicate the creation time of the Data.

One of the main reasons to recommend timestamp as a value for the version is the ultimate goal for the version component be numerically larger for the ``latest'' version.
Timestamp provides a relative easy way to achieve this goal for single or multi-producer applications, assuming the producer will take care of properly synchronizing their clocks.
If clock synchronization is not feasible for a distributed application, this application must make all attempts in some other way to ensure version property.
Otherwise, the use of the defined versioning marker may harm the application, as third-parties may incorrectly treat Data packet with the ``largest'' version as the ``latest'' (e.g., prioritize caching of it).

\begin{table}[h!]
  \centering
  \caption{Versioning marker}
  \label{tab:versioning}
  \begin{tabular}{|l|l|l|}
    \hline
    Marker & Value meaning \\
    \hline \hline
    \verb|0xFD| & Number of milliseconds since UNIX epoch \\
    \hline
  \end{tabular}
\end{table}


\subsubsection{Sequencing}
\label{sec:sequencing}

Sequencing data collections is another common feature in many applications.
Named Data Networking daemon (NFD)~\cite{nfd} uses such collections as part of the face status notification protocol; ChronoSync~\cite{ChronoSync} protocol provide efficient synchronization primitives for sequenced data collections.
While the sequence number value in these collections is syntactically similar to sequence-based segmentation, the sequence number has a very different meaning.
Third parties (e.g, ContentStore) that can understand this difference, may provide better help with data retrieval for the applications properly using segmentation and sequencing conventions.

Naming convention for sequence is defined in Table~\ref{tab:sequencing}: marker \verb|0xFE| followed by the sequence number of the Data packet in the dataset.

\begin{table}[h!]
  \centering
  \caption{Sequencing marker}
  \label{tab:sequencing}
  \begin{tabular}{|l|l|l|}
    \hline
    Marker & Value meaning \\
    \hline \hline
    \verb|0xFE| & Sequence number of the Data in the dataset \\
    \hline
  \end{tabular}
\end{table}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "convention"
%%% End:
